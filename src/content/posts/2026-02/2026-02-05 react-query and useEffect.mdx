---
title: "react-query 와 useEffect는 반비례"
slug: "react-query-and-useEffect"
pubDate: "2026-02-05 21:55:00"
summary: "react-query와 useEffect의 관계를 알아보자"
tags: ["react", "react-query"]
---

React Query(TanStack Query)를 사용하면,  
서버에서 데이터를 가져오고 **캐싱 · 동기화 · 상태 관리**하는 작업이 훨씬 간편해진다.  
그 결과, **데이터 패칭을 목적으로 useEffect를 사용하는 빈도는 크게 줄어들게 된다.**

---

## 1. 기존의 useEffect 처리 방식

기존 React에서는 `useEffect`의 `componentDidMount` 역할을 활용해  
컴포넌트가 마운트될 때 데이터를 가져오는 방식을 많이 사용했다.

```tsx
import { useEffect, useState } from "react";

function MyComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("/api/data")
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []);

  return <div>{data ? JSON.stringify(data) : "Loading..."}</div>;
}
```

`useEffect`의 두 번째 인자를 빈 배열(`[]`)로 설정하면,
컴포넌트가 **처음 렌더링될 때 한 번만 실행**된다.

이 방식은 개념적으로
`document.addEventListener("DOMContentLoaded", ...)` 와 유사한 역할을 한다.

---

## 2. useEffect 기반 데이터 패칭의 한계와 단점

### 1) 코드 중복

여러 컴포넌트에서 동일한 API를 호출하면
패칭 로직이 반복적으로 작성되기 쉽다.

### 2) 로딩 / 에러 상태를 직접 관리해야 함

```tsx
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);
```

같은 상태들을 매번 직접 만들어야 한다.

### 3) 캐싱과 중복 요청 처리의 부담

useEffect 자체가 문제라기보다는,
**캐싱 · 재시도 · 중복 요청 방지 로직을 직접 구현해야 한다는 점**이 부담이다.

### 4) 의존성 배열 관리의 어려움

```tsx
function getData() {
  return fetch("/api/data").then((res) => res.json());
}

useEffect(() => {
  getData().then((data) => setData(data));
}, [someDependency]);
```

* `someDependency`가 자주 변경되면 불필요한 재요청 발생
* 잘못 설정하면 무한 루프 위험

결국, **의존성 배열을 항상 신경 써야 한다는 점**이 유지보수 비용으로 이어진다.

---

## 3. React Query(TanStack Query)의 핵심 장점

React Query는 Redux나 Zustand 같은 “전역 상태관리 라이브러리”라기보다는,
**서버 상태(Server State)를 전문적으로 다루는 도구**에 가깝다.

### 주요 장점

1. **중앙 집중식 서버 상태 캐시 관리**

   * QueryClient가 서버 데이터를 캐시로 관리
   * 여러 컴포넌트가 동일한 `queryKey`로 데이터 공유 가능

2. **자동 캐싱 및 중복 요청 방지**

   * 같은 쿼리는 네트워크 요청을 반복하지 않음

3. **로딩 / 에러 상태 자동 제공**

   * `isLoading`, `isError`, `error` 등 기본 제공

4. **백그라운드 데이터 갱신**

   * 포커스 복귀, stale 상태 등 조건에 따라 자동 재검증

5. **간편한 무효화 및 재요청**

   * `invalidateQueries`로 손쉽게 최신 데이터 동기화

---

## 4. React Query를 사용한 데이터 패칭

React Query를 사용하면
**데이터 패칭을 위해 useEffect를 직접 작성할 필요가 거의 없어지게 된다.**

> ❗️중요 포인트
> useEffect가 완전히 사라지는 것이 아니라,
> **“데이터 패칭 목적의 useEffect”가 대체된다**는 의미다.

```tsx
import { useQuery } from "@tanstack/react-query";

function MyComponent() {
  const { data, isLoading } = useQuery({
    queryKey: ["fetchData"],
    queryFn: () =>
      fetch("/api/data").then((response) => response.json()),
  });

  if (isLoading) {
    return <div>Loading...</div>;
  }

  return <div>{JSON.stringify(data)}</div>;
}
```

* 컴포넌트가 해당 쿼리를 **구독**하는 순간
* 캐시 상태에 따라 자동으로 fetch가 트리거된다
  (마운트 시 1회 요청과 유사한 동작)

---

## 5. useEffect가 여전히 필요한 경우

React Query가 모든 useEffect를 대체하는 것은 아니다.

### 예시 1) 쿼리 결과로 부수 효과 실행

```tsx
const { isSuccess } = useQuery({
  queryKey: ["me"],
  queryFn: fetchMe,
});

useEffect(() => {
  if (isSuccess) {
    toast("유저 정보 로딩 완료!");
  }
}, [isSuccess]);
```

### 예시 2) 조건부 요청 (`enabled`)

```tsx
useQuery({
  queryKey: ["user", userId],
  queryFn: () => fetchUser(userId),
  enabled: !!userId, // userId가 있을 때만 요청
});
```

이런 경우는 **useEffect 대신 React Query 옵션으로 해결 가능**하다.

---

## 6. React Query Devtools 활용

React Query Devtools를 사용하면
쿼리 상태와 캐시 데이터를 시각적으로 확인할 수 있다.

### 1) 설치

```bash
npm install @tanstack/react-query-devtools
```

### 2) 설정

```tsx
import {
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourAppComponents />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### 3) 확인 가능한 정보

* 쿼리 상태 (idle / loading / success / error)
* 캐시된 데이터 내용
* 쿼리 무효화 및 수동 재요청
* stale / fresh 상태 확인

---

## 7. 정리

* useEffect는 **여전히 중요한 React Hook**
* 하지만 **서버 데이터 패칭을 담당하기에는 역할이 과도해진 상태**
* React Query는 이 역할을 전문적으로 분리해준다

결론적으로,
**React Query를 사용하면 데이터 패칭을 위한 useEffect는 거의 사용하지 않게 된다.**
이는 React 구조를 더 단순하고 예측 가능하게 만들어준다.

---

## 8. 참고 자료

* [tanstack-query 공식사이트](https://tanstack.com/query/latest)
* [React Query 시작하기 (feat. useEffect로 데이터 패칭하는 것의 단점!)](https://velog.io/@mikio/React-Query-시작하기-feat.-useEffect로-데이터-패칭하는-것의-단점)