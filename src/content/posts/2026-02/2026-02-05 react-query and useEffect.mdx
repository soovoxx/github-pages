---
title: "react-query 와 useEffect는 반비례"
slug: "react-query-and-useEffect"
pubDate: "2026-02-05 21:55:00"
summary: "react-query와 useEffect의 관계를 알아보자"
tags: ["react", "react-query"]
---

React Query를 사용하면, 데이터를 가져오고 관리하는 작업이 훨씬 간편해짐, <br/>
따라서 useEffect를 사용하여 데이터를 가져오는 빈도가 줄어듦

## 1. 기존의 useEffect 처리방식

보통은 useEffect의 componentDidMount 역할을 활용하여, <br/>
컴포넌트가 마운트될 때 데이터를 가져오는 작업을 수행하게 함

```tsx
import { useEffect, useState } from "react";

function MyComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("/api/data") 
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []);

  return <div>{data ? JSON.stringify(data) : "Loading.. ."}</div>;
}
```

useEffect의 두번째 인자를 빈배열로 설정하면, <br/> 
`document.addEventListener('DOMContentLoaded', ...)` 와 동일하게 컴포넌트가 처음 렌더링될 때만 실행됨

## 2. useEffect로 처리할때, 한계와 단점

1. **코드 중복** : 여러 컴포넌트에서 동일한 데이터 패칭 로직이 반복될 수 있음 <br/>
2. **로딩 및 에러 상태 관리** : 로딩 상태와 에러 처리를 직접 구현해야 함 <br/>
3. **캐싱 부족** : 동일한 데이터를 여러번 가져올 때마다 네트워크 요청이 발생함 <br/>
4. **복잡한 의존성 관리** : 의존성 배열을 잘못 설정하면 무한 루프가 발생할 수 있음

```tsx
function getData(){
    return fetch("/api/data") 
        .then((response) => response.json());
}

/* codes */

useEffect(() => {
    getData().then((data) => setData(data));
}, [someDependency]); // someDependency가 자주 변경되면, 불필요한 재요청이 발생할 수 있음
``` 

useEffect의 배열 의존성을 잘못 설정하면, 문제가 발생할 수 있음(예: 무한 루프) <br/>
따라서, 의존성 배열을 신중하게 관리해야 함

## 3. React Query의 장점

1. **중앙 집중식 데이터 관리** : 전역 상태로 데이터를 관리하여, 여러 컴포넌트에서 쉽게 접근 가능 <br/>
2. **자동 캐싱 및 갱신** : 동일한 데이터를 여러번 요청할 때, 캐시된 데이터를 사용하여 네트워크 요청을 줄임 <br/>
3. **로딩 및 에러 상태 자동 관리** : 로딩 상태와 에러 처리를 내장하여, 개발자가 직접 구현할 필요 없음 <br/>
4. **백그라운드 데이터 갱신** : 데이터가 오래되었을 때 자동으로 백그라운드에서 갱신 가능 <br/>
5. **간편한 쿼리 무효화 및 재요청** : 쿼리를 쉽게 무효화하고, 데이터를 다시 가져올 수 있음

## 4. React Query를 사용했을때의 처리

React Query를 사용할때는 useEffect를 더이상 사용하지 않게됨( point ! ) <br/>
그 이유는 React Query가 자체적으로 데이터 가져오기, 캐싱, 갱신 로직을 처리하기 때문임


`queryKey`는 쿼리의 고유한 키이고, `queryFn`은 데이터를 가져오는 함수 <br/>
이렇게 명시적으로 작성하면 코드의 가독성이 더 높아집니다.

```tsx
import { useQuery } from "react-query";

function MyComponent() {
  const { data, isLoading } = useQuery({
    queryKey: ["fetchData"],
    queryFn: () =>
      fetch("/api/data").then((response) => response.json())
  }); // 해당 시점에 이미 componentDidMount(useEffect의 빈 배열) 역할이 포함됨

  if (isLoading) {
    return <div>Loading...</div>;
  }

  return <div>{JSON.stringify(data)}</div>;
}
```

따라서 `React Query`를 사용하면, `useEffect`를 사용하여 데이터를 가져오는 빈도가 현저히 줄어들게 됨 <br/>

결론적으로, `React Query`를 사용하면 `useEffect`를 통한 데이터 가져오기 작업이 불필요해짐 <br/>
(물론, `useEffect`가 여전히 필요한 경우도 있지만, 데이터 패칭과 관련된 작업에서는 `React Query`가 훨씬 효율적이라는 얘기)

## 5. react query devtools 상태

React Query Devtools를 사용하면, 애플리케이션의 데이터 패칭 상태를 시각적으로 확인할 수 있음 <br/>
이를 통해 쿼리의 상태, 캐시된 데이터, 로딩 상태 등을 쉽게 파악할 수 있음

1. **설치**
```bash
npm install @tanstack/react-query-devtools
```

2. **사용**
```tsx
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { QueryClient, QueryClientProvider } from 'react-query';
const queryClient = new QueryClient();
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourAppComponents />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

3. **기능**
- 쿼리 상태 시각화 : 각 쿼리의 상태(로딩, 성공, 실패 등)를 한눈에 확인 가능
- 캐시 데이터 확인 : 현재 캐시된 데이터를 조회하고, 필요시 수동으로 갱신 가능
- 쿼리 무효화 및 재요청 : 쿼리를 무효화하고 다시 요청할 수 있는 기능 제공
- 성능 모니터링 : 쿼리의 성능을 모니터링하여 최적화에 도움

## 6. 참고자료

- [React Query 공식문서](https://tanstack.com/query/v4)
- [React Query 시작하기 (feat. useEffect로 데이터 패칭하는 것의 단점!)](https://velog.io/@mikio/React-Query-시작하기-feat.-useEffect로-데이터-패칭하는-것의-단점)