---
title: "모놀리식 레포지토리 프로젝트의 문제"
slug: "mono-repository-2"
pubDate: "2025-11-10 15:39:30"
summary: "모놀리식 레포의 개발/배포/운영간 발생할 수 있는 문제들"
category: "msa"
series: "Microservice Architecture"
tags: ["msa", "mono-repo"]
---

# 서론

MSA 도입이 왜 필요한지 이해하려면, 전통적인 모놀리식 레포가 개발·배포·운영 과정에서 어떤 한계를 드러냈는지 살펴볼 필요가 있습니다. 이 글에서는 대학 정보시스템을 예시로 들어, 모놀리식 레포지토리 프로젝트에서 실제로 발생하는 문제들을 정리합니다.

## 1. 개발 단계에서 생기는 문제들

### a. 공통 모듈 변경 시 전체 서비스 리스크

- 공통 모듈 하나 수정했는데, 다른 팀 기능 터지는 경험 이미 한 번 했던 것처럼
- 추가는 괜찮은데, 수정/삭제는 무섭다 모드가 생김
  → 결과적으로 레거시 코드가 계속 쌓이고, 아무도 못 건드리는 구역이 생김.

> **예시**
>
> `common-utils`, `core-domain` 같은 데에 “전사 공용 함수/DTO” 들어가 있고
>
> 한 줄 수정했는데, 학사/등록/장학/성적 쪽이 전부 동시에 영향 받는 구조.

### b. 전체 빌드 및 테스트 시간이 과도하게 길어짐

- 코드가 한 레포/한 프로젝트에 다 있으니:
  - 작은 수정 하나 해도 **전체 빌드**
  - 통합 테스트 세트도 같이 도는 경우가 많음
- "로컬에서 빌드만 10분 걸린다" 이런 상황 오기 쉬움

> 결국
>
> 개발자들이 "테스트 스킵하고 커밋 → CI에서만 믿는다" 패턴 생기고
>
> CI도 점점 느려지고, PR 머지 속도도 떨어짐

### c. 도메인 경계와 의존 관계의 혼란

- 모듈/패키지로 나눴다고 해도, 물리적으로는 한 코드베이스라서:
- `student` 쪽에서 `professor` 내부 객체 직접 참조
- `payment` 쪽에서 `grade` 도메인 상태를 직접 건드림
- **이런 식으로 Layer는 나뉜 것 같아도, 도메인 경계는 막 뚫려 있는 경우가 많음**

결과 >> 의존 흐름이 복잡해지고, 순환참조 가까운 구조가 생겨 _이거 지우면 뭐가 터질지 모르니까 일단 손대지 말자_ 가 됨

### d. 의존성 관리와 버전 업그레이드의 어려움

- 레포 하나에 여러 팀/기능이 같이 쓰니까:
  - 어떤 팀은 `Spring 5` 기능 쓰고 싶은데, 다른 팀이 `Spring 4` 전용 코드 잔뜩 써놓음
  - `Jackson`, `JPA`, `Lombok` 버전 업하려고 해도 **옛날 코드와의 호환** 때문에 못 올리는 상황
- 결국 가장 뒤처진 요구사항에 맞춰 전체가 발목 잡히는 구조가 됨.

---

## 2. 협업 / 브랜치 / 코드 관리

### a. PR 충돌과 거대한 머지

- 공통 모듈/DTO/엔티티를 여러 팀이 손대다 보니:
  - 항상 같은 파일이 `conflict` 대상 (ex. java의 상수 파일 `Constraint.java`, react, vue의 `endpoint.ts` 등등)
  - 릴리즈 직전에 `diff`가 수천 줄인 PR이 등장
- 리뷰도 형식적이 되고, “누가 어떤 부분의 오너인지”가 모호해짐

### b. 코드 오너쉽 불명확

- **이 클래스 누구 담당이야?** → 아무도 확실히 대답 못함
- 공용 모듈일수록 더 그렇고, 책임도 애매하게 흩어짐 (??? : 아 이거 내담당아닌데 ㅜㅜ)

---

## 3. 테스트 / 품질 보증 구간(QA)

### a.테스트 범위가 너무 넓음

- 기능 하나 추가했는데, 이게 다른 도메인에까지 영향 줄 수 있어서
  - QA에서 **전체 회귀 테스트** 를 자꾸 요구 (테스트의 범위가 엄청 넓어짐, 특히 공통모듈을 건드리면 큰일남)
  - 일정이 늘어지고, 작은 변경도 릴리즈가 무거워짐.

### b. "부분배포" 가 힘듦

- MSA면 service A만 새 버전 올리고, 문제 있으면 A만 롤백하면 되는데

* 모놀리식이면:
  - A의 신규 기능 + B의 기존 기능이 한 번에 올라감
  - A 때문에 배포했는데 B가 깨지면 → 전체 롤백
* 이게 쌓이면:
  - "배포는 최대한 적게 하자", "릴리즈 묶어서 한 번에" 문화로 가고
  - 기능 출시 리드타임이 길어짐.

---

## 4. 배포 단계 문제

### a. 올-오어-낫싱(All-or-Nothing) 배포

- 하나의 큰 애플리케이션(`JAR`/`WAR`)이라:
  - 일부 기능만 새로 배포하는 게 아니라, 전체 교체
- 롤백도 전체 교체라,
  - A 기능은 좋았는데 B 때문에 롤백하는 경우 자주 발생

### b. 다운타임·배포 리스크가 크다

- 서버가 분리되어있지 않거나, 무중단 배포 안 잡혀 있으면:
  - 배포 = 서비스 중단
  - 학사 일정(수강신청 기간, 성적 입력 기간)에 배포 타이밍이 극도로 제한됨

### c. Blue-Green/Canary 같은 전략이 어려움

- 논리적으로는 모놀리식에도 Blue-Green 가능하지만,
  - 트래픽 분배를 "기능 단위" 로 못 하고, 앱 전체만 **On/Off** 할 수 있음

---

## 5. 운영(장애/성능/스케일링) 단계 문제

### a. 장애 범위가 너무 크다

- 한 기능에서:
  - 메모리 릭
  - 스레드 풀 고갈
  - DB Connection 유출 등이 나도, 같은 JVM, 같은 DB 풀, 같은 서버를 쓰는 모든 기능이 같이 죽음

> Ex
> 증명서 PDF 생성 모듈이 메모리 많이 먹다가 OOME 발생
>
> 로그인/수강신청/성적조회 전부 500 에러
>
> ※ OOME는 **Out Of Memory Error(Exception) = JVM의 메모리가 부족하여 발생한 에러**

### b. 성능 튜닝이 전체 공통

- JVM 옵션, GC 정책, 최대 스레드 수, 커넥션 풀 사이즈 등
  - 학사 API, 배치, 파일 업로드, BI 리포트, 백오피스가 다 같이 씀
- 어떤 기능은 CPU 바운드, 어떤 기능은 I/O 바운드인데, 전부 한 세트의 옵션으로 튜닝해야 해서 타협점만 찾게 됨.

### c. 스케일링 단위가 너무 크다

- 특정 기능만 트래픽이 높아도:
  - 앱 전체 인스턴스를 늘려야 함
  - 예: 수강신청 기능만 미친 트래픽인데, 교수용 화면/관리자용 화면까지 같이 스케일링
- 인프라 비용도 같이 올라감.

### d. 로그/모니터링이 복잡

- 하나의 애플리케이션 로그 안에:
  - 로그인, 조회, 배치, 백오피스, 크론, 외부 연동까지 전부 섞임
- A 기능 장애를 찾고 싶은데, B, C, D 기능 로그도 동일 파일에 섞여 있어서 필터링/추적이 어려움.

### e. 배치와 온라인이 자원 경쟁

- 같은 JVM 안에:
  - 웹 요청 처리 코드
  - 야간 배치 작업이 같이 들어있으면,
- 배치 돌 때:
  - CPU/메모리/DB 세션을 많이 잡아먹고,
  - 그 시간대엔 웹 응답이 느려지거나 타임아웃 날 수 있음(따라서 이용자가 적은 새벽시간에 배치를 돌리는경우가 많음)

---

## 6. 데이터베이스 쪽 문제

### a. 단일 거대 스키마

- 학사, 인사, 재무, 장학, 시설, 로그 등등이 전부 한 DB, 한 스키마 쓸 경우:
  - `마이그레이션/DDL` 변경이 매우 위험
  - 한 테이블 락 잡은 쿼리가 전체 서비스의 병목이 되기도 함

### b. 롱 트랜잭션의 영향

- 어떤 기능이 30초짜리 트랜잭션을 날리면,
  - 그 테이블에 대한 다른 요청이 줄줄이 대기
  - 실시간 API도 덩달아 느려짐

---

## 7. 조직/프로세스 관점 문제

### a. 팀 독립성이 거의 없음

- MSA면 팀별로 "**우리 서비스는 우리가 배포/운영**" 이 가능한데,
- 모놀리식/대규모 모노레포면:
  - 배포 일정, 변경 승인, QA, 운영 이슈를 전부 같이 맞춰야 함
  - 작은 기능도 "전체 릴리즈 캘린더" 에 묶임

### b. 신기능 출시 속도 저하

- 내 팀 기능은 개발 다 끝났는데
  - 다른 팀은 아직 QA 중이라 릴리즈 못 하는 상황 자주 나옴
- 그러다 보면:
  - 기능 단위 배포가 아니라, "분기별 대규모 릴리즈" 식으로만 움직이게 됨
- 빠른 실험/피봇이 어려움
