---
title: "custom-annotation 구현 & 적용"
slug: "custom-annotation"
pubDate: "2025-12-10"
summary: "커스텀 어노테이션"
tags: ["kotlin", "custom-annotation"]
---

# **1. 커스텀 어노테이션 선언**

```java
- LogExecutionTime.java

@Target(AnnotationTarget.FUNCTION  )
@Retention(AnnotationRetention.RUNTIME)
annotation class LogExecutionTime
```

---

# **2. AOP Aspect 만들기**

메소드 실행 전후 시간을 찍는 @Around Advice를 작성.

```kotlin
- LogExecutionTimeAspect.kt

@Aspect
@Component
class LogExecutionTimeAspect {

    private val logger = LoggerFactory.getLogger(this::class.java)

    @Around("@annotation(com.example.LogExecutionTime)")
    fun logExecutionTime(joinPoint: ProceedingJoinPoint): Any? {
        val start = System.currentTimeMillis()

        // 실제 메소드 실행
        val result = joinPoint.proceed()

        val end = System.currentTimeMillis()
        val methodName = "${joinPoint.signature.declaringType.simpleName}.${joinPoint.signature.name}"

        logger.info("[${methodName}] 실행 시간: ${end - start} ms")

        return result
    }
}
```

**설명 예시 느낌으로**

예를 들어, 컨트롤러에 getPlayer() 메소드가 있으면:

```kotlin
@LogExecutionTime
fun getPlayerByName(name: String): ResPlayerDetailDTO? {
    val player = playerRepository.findByName(name)
    return player?.let { PlayerConverter.toResPlayerDetailDTO(it) }
}
```

실행하면 로그에 이런식으로 찍힘:

```bash
[PlayerService.getPlayerByName] 실행 시간: 239 ms
```

# **마무리 예시**

전체 흐름은 이렇게 돼:

1. @LogExecutionTime 어노테이션을 메소드에 붙여
2. AOP가 그 메소드 호출을 가로채서
3. 실행 전 시간 기록 → 메소드 실행 → 실행 후 시간 기록
4. 차이를 로그로 출력

**“시작~종료까지 걸린 시간 로그 찍기” 요구사항에 딱 맞는 패턴**
