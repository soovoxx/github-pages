---
title: "UI5와 다른 프론트엔드 언어 비교"
slug: "about-ui5-2"
pubDate: "2025-12-14 06:17:00"
summary: "ui5, react, vue 비교"
category: "ui5"
series: "SAP-UI5"
tags: ["ui5"]
---

[1편](/github-pages/post/about-ui5) 에서 계속됩니다

## 1. SAPUI5 예제를 React로 표현하면

<!-- prettier-ignore -->
```js
// App.jsx
import { createRoot } from "react-dom/client";
import App from "./App";

const rootElement = document.getElementById("root");
createRoot(rootElement).render(<App />);

// Message.jsx
const Message = () => {
  // set variable
  const [message, setMessage] = useState<string>("Hello SAPUI5");

  // state change
  const handleClick = () => {
    alert("button click ");
  };

  // return DOM element
  return (
    <div className="content">
      <Text text={message} />
      <button onClick={handleClick}>click!</button>
    </div>
  );
};

export default Message;
```

> `App.tsx`, `Message.tsx` 파일두개로 끝난다

### a. view 부분

```js
// react
return (
  <div className="content">
    <span>{message}</span>
    <button onClick={handleClick}>click!</button>
  </div>
);
```

```xml
<!-- sap-ui5 view -->
<content>
  <Text text="{/message}" />
  <Button text="클릭" press="onPress" />
</content>
```

> react의 경우는 DOM파일이 보통 함수의 가장아래 return 키워드 아래에 위치해있다. <br/>
> sap-ui5 경우는 view 파일이 view package 하위에 위치하고 있음

### b. controller

```js
// React
handleClick = () => {
  alert("button click ");
};
```

```js
// UI5
sap.ui.define(["sap/ui/core/mvc/Controller"], function (Controller) {
  "use strict";

  return Controller.extend("my.app.controller.Main", {
    onPress: function () {
      alert("버튼 클릭!");
    },
  });
});
```

> React의 경우 컴포넌트 내부에 상태 선언(`useState`), 이벤트 핸들러(`handle method`), 렌더링 로직(`return ()`)이 함께 위치함. <br/>
> 이 때문에(예제기준) SAP UI5가 추구하는 전통적인 MVC 관점에서 보면, 굳이 controller를 분리하는 구조가 의미 없어 보일 수도 있다. <br/>
> 다만 화면과 로직을 강제로 분리하는 UI5 구조 덕분에, 코드 규모가 커졌을 때는 **오히려 가독성이 좋아질 가능성도 있어 보임**

### c. Model

각각 화면에서 쓸 데이터는 아래의 코드처럼 사용하고

<!-- prettier-ignore -->
```js
// React 
const [message, setMessage] = useState<string>("Hello SAPUI5");
```

```js
// UI5
var oModel = new sap.ui.model.json.JSONModel({
  message: "Hello SAPUI5",
});
this.getView().setModel(oModel);
```

각각 선언한 변수사용은 아래와 같음

```js
// React
return (
  // source code
  <Text text={message} />
);
```

```xml
<!-- UI5 -->
<Text text="{/message}" />
```

> 다만 UI5의 Model은 View와의 바인딩이 명확하게 분리되어 있어<br/>
> 여러 View에서 동일 데이터를 공유할 때는 구조적으로 유리한 편이다.

### d. Component

```js
// React
import { createRoot } from "react-dom/client";
createRoot(document.getElementById("root")).render(<App />);
```

<!-- prettier-ignore -->
```js
// UI5
return UIComponent.extend("my.app.Component", {
  metadata: {
    manifest: "json",
  },
  init: function () {
    UIComponent.prototype.init.apply(this, arguments);
  },
});

// UI5 boot code - place the component on the page
sap.ui.define(["sap/ui/core/ComponentContainer"], function (ComponentContainer) {
  "use strict";
  new ComponentContainer({
    name: "my.app",
    async: true,
  }).placeAt("content");
});
```

### e. manifest.json

React 기준으로 이부분을 완벽히 대신할 부분은 없으나, 역할로 보면 `package.json + index.js + react router` 기능을 합친것과 같음

- 라이브러리 통합관리(React는 `package.json`, UI5는 `sap.ui5/dependencies` 해당부분에서 관리)
- 루트뷰 설정 (React는 `src/index.js`가, UI5는 `sap.ui5/rootView` 해당부분에서 관리)
- 라우터 관리 (React에서는 라우팅이 프레임워크 기본 기능이 아니라 선택 사항임) <br/>
  보통 `react-router-dom` 같은 외부 라이브러리를 직접 설치한 뒤, `App.js` 혹은 별도의 `routes.tsx` 파일에서 <BrowserRouter>, <Routes>, <Route> 컴포넌트를 사용해 라우팅을 코드로 정의한다.
  이 방식은 JavaScript 로직 안에서 동적으로 제어할 수 있어 유연하지만, 라우팅 구조가 코드 곳곳에 흩어질 수 있고 초기 진입 시 전체 구조를 한눈에 파악하기는 어렵다.

- 반면 UI5는 라우팅을 `manifest.json`에서 선언적으로 관리함<br/>
  URL 패턴, 대상 View, View 레벨 등을 JSON 설정으로 정의해두면, 앱 시작 시 자동으로 Router가 초기화되고 URL에 따라 View 전환이 이루어진다.
  라우팅 정보가 코드가 아닌 설정 파일에 모여 있기 때문에, 화면 전환 구조를 빠르게 파악할 수 있고 대규모 엔터프라이즈 애플리케이션에서도 일관된 네비게이션 구조를 유지하기 쉽다.
  정리하면, React의 라우팅은 "코드 중심의 유연한 구성", UI5의 라우팅은 **설정 중심의 표준화된 구성** 에 가깝다고 볼 수 있다.
