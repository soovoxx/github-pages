---
import type { AstroComponentFactory } from "astro/runtime/server/index.js";
import { baseUrl } from "@/constants";
import "@/styles/markdown.scss";
import type { PostSummary } from "@/lib/post";

interface TocHeading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  title: string;
  summary?: string;
  tags: string[];
  parsedPubDate: Date;
  tocHeadings: TocHeading[];
  navContext?: string;
  prevPost?: PostSummary;
  nextPost?: PostSummary;
  linkPrefix?: string;
  Content: AstroComponentFactory;
}

const {
  Content,
  title,
  tags,
  summary,
  parsedPubDate,
  tocHeadings,
  navContext = "전체 글에서 이어보기",
  prevPost,
  nextPost,
  linkPrefix = `${baseUrl}/post`,
} = Astro.props as Props;
---

<div class="post-layout">
  <article class="post">
    <p class="eyebrow">{parsedPubDate.toLocaleDateString("ko-KR")}</p>
    <h1 class="title">{title}</h1>
    <div class="summary">{summary}</div>
    <div class="tags">
      {
        tags.map((t) => (
          <a class="tag" href={`${baseUrl}/tags/${encodeURIComponent(t)}`}>
            #{t}
          </a>
        ))
      }
    </div>
    <div class="content">
      <Content />
    </div>
    {
      (prevPost || nextPost) && (
        <nav class="post-nav" aria-label="Post navigation">
          <p class="nav-context">{navContext}</p>
          <div class="nav-links">
            {prevPost ? (
              <a class="nav-link" href={`${linkPrefix}/${prevPost.slug}`}>
                <span class="nav-label">이전 포스트</span>
                <span class="nav-title">{prevPost.title}</span>
              </a>
            ) : (
              <span aria-hidden="true" />
            )}
            {nextPost ? (
              <a class="nav-link" href={`${linkPrefix}/${nextPost.slug}`}>
                <span class="nav-label">다음 포스트</span>
                <span class="nav-title">{nextPost.title}</span>
              </a>
            ) : (
              <span aria-hidden="true" />
            )}
          </div>
        </nav>
      )
    }
  </article>

  {
    tocHeadings.length > 0 && (
      <aside class="toc" aria-label="On this page">
        <div class="toc-body">
          <div class="toc-progress" aria-hidden="true">
            <div class="toc-progress-bar" />
          </div>
          <ul class="toc-list">
            {tocHeadings.map((heading) => (
              <li class="toc-item">
                <a
                  class="toc-link"
                  style={`padding-left: ${6 + Math.max(0, heading.depth - 1) * 10}px`}
                  href={`#${heading.slug}`}
                >
                  {heading.text}
                </a>
              </li>
            ))}
          </ul>
        </div>
      </aside>
    )
  }
</div>

<script is:inline>
  const tocLinks = Array.from(document.querySelectorAll(".toc a"));
  const headings = Array.from(
    document.querySelectorAll(".content :is(h1, h2, h3, h4)"),
  ).filter((heading) => heading.id);

  if (tocLinks.length && headings.length) {
    const linkTargets = tocLinks.map((link) => ({
      link,
      id: decodeURIComponent(link.hash.slice(1)),
    }));

    const scrollOffset = 80;
    let lastActiveId = headings[0]?.id || "";
    let lastSeenId = lastActiveId;

    const setActive = (id) => {
      lastActiveId = id;
    };

    const scrollToHeading = (id) => {
      const target = document.getElementById(id);
      if (!target) return;
      const targetTop =
        target.getBoundingClientRect().top + window.scrollY - scrollOffset;
      window.scrollTo({ top: Math.max(0, targetTop), behavior: "smooth" });
    };

    const headingOrder = new Map(
      headings.map((heading, index) => [heading.id, index]),
    );
    const visibleHeadings = new Set();
    const progressBar = document.querySelector(".toc-progress-bar");
    const postEl = document.querySelector(".post");
    const tocAside = document.querySelector(".toc");

    const updateActiveFromVisible = () => {
      if (!headings.length) return;
      if (!visibleHeadings.size) {
        if (lastSeenId) setActive(lastSeenId);
        return;
      }

      const orderedVisible = [...visibleHeadings].sort(
        (a, b) => headingOrder.get(a) - headingOrder.get(b),
      );
      const activeId = orderedVisible[orderedVisible.length - 1];
      lastSeenId = activeId;

      setActive(activeId);
    };

    const updateProgressBar = () => {
      if (!(progressBar && postEl)) return;
      const postTop = postEl.getBoundingClientRect().top + window.scrollY;
      const postHeight = postEl.offsetHeight;
      const viewHeight = window.innerHeight;
      const denominator = Math.max(1, postHeight - viewHeight);
      const ratio = Math.min(
        Math.max((window.scrollY - postTop) / denominator, 0),
        1,
      );
      progressBar.style.height = `${ratio * 100}%`;

      if (tocAside) {
        const pastEnd = window.scrollY + viewHeight > postTop + postHeight + 20;
        tocAside.classList.toggle("over-end", pastEnd);
      }
    };

    let progressTicking = false;
    const onScroll = () => {
      if (!progressTicking) {
        window.requestAnimationFrame(() => {
          updateProgressBar();
          progressTicking = false;
        });
        progressTicking = true;
      }
    };

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const { id } = entry.target;
          if (!id) return;

          if (entry.isIntersecting) {
            visibleHeadings.add(id);
          } else {
            visibleHeadings.delete(id);
          }
        });

        updateActiveFromVisible();
      },
      {
        root: null,
        rootMargin: `${-(scrollOffset + 10)}px 0px -60% 0px`,
        threshold: [0, 0.2, 0.4, 0.6, 0.8, 1],
      },
    );

    headings.forEach((heading) => observer.observe(heading));
    if (lastSeenId) setActive(lastSeenId);
    updateActiveFromVisible();
    updateProgressBar();

    const hash = decodeURIComponent(window.location.hash.replace("#", ""));
    if (hash) {
      scrollToHeading(hash);
      setActive(hash);
      history.replaceState(
        null,
        "",
        window.location.pathname + window.location.search,
      );
    }

    linkTargets.forEach(({ link, id }) => {
      link.addEventListener("click", (event) => {
        event.preventDefault();
        scrollToHeading(id);
        setActive(id);
        history.replaceState(
          null,
          "",
          window.location.pathname + window.location.search,
        );
      });
    });

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", () => {
      updateProgressBar();
      updateActiveFromVisible();
    });
  }
</script>

<style lang="scss">
  :global(html) {
    scroll-behavior: smooth;
  }

  .post-layout {
    .post {
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
      background: color-mix(in srgb, var(--panel) 88%, transparent);
      padding: 30px 44px;
      border-radius: 24px;
      border: 1px solid color-mix(in srgb, var(--text) 10%, transparent);
      box-shadow: 0 18px 40px var(--shadow);

      h1 {
        margin: 15px 0;
      }

      .summary {
        display: flex;
        justify-content: flex-end;
        color: var(--muted);
        margin: 6px 0 4px;
        font-size: 1.02em;
        line-height: 1.6;
      }

      .tags {
        display: flex;
        gap: 5px;
        justify-content: flex-end;
        padding: 10px 0;
        color: var(--muted);

        .tag {
          font-size: 0.9em;
          padding: 3px 6px;
          background-color: color-mix(in srgb, var(--text) 5%, transparent);
          border-radius: 10px;
          letter-spacing: 0.05em;
          cursor: pointer;
          text-decoration: none;
          color: inherit;
        }
      }

      .content {
        :is(h2, h3, h4) {
          scroll-margin-top: 120px;
        }
      }

      .post-nav {
        margin-top: 28px;
        display: grid;
        gap: 10px;

        .nav-context {
          margin: 0;
          color: var(--muted);
          font-weight: 700;
        }

        .nav-links {
          display: grid;
          grid-template-columns: repeat(2, minmax(0, 1fr));
          gap: 12px;
        }

        .nav-link {
          display: grid;
          gap: 4px;
          padding: 12px 14px;
          background: var(--panel);
          border: 1px solid color-mix(in srgb, var(--text) 10%, transparent);
          border-radius: 12px;
          color: var(--text);
          text-decoration: none;
          box-shadow: 0 10px 24px var(--shadow);
          transition:
            transform 0.15s ease,
            box-shadow 0.2s ease;

          &:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 30px var(--shadow);
          }

          .nav-label {
            font-size: 0.9rem;
            color: var(--muted);
          }

          .nav-title {
            font-weight: 700;
          }
        }
      }
    }

    .toc {
      position: fixed;
      top: 120px;
      align-self: start;
      border-radius: 16px;
      padding: 4px;
      max-height: calc(100vh - 160px);
      overflow: auto;
      right: 3%;
      font-size: 12px;
      min-width: 290px;
      max-width: 290px;
      transition: opacity 0.18s ease;

      .toc-body {
        display: grid;
        grid-template-columns: 6px 1fr;
        align-items: start;
        height: 100%;
      }

      .toc-progress {
        position: relative;
        height: 100%;
        min-height: 120px;
        width: 6px;
        border-radius: 999px;
        overflow: hidden;
        background: color-mix(in srgb, var(--text) 14%, transparent);
        box-shadow: inset 0 0 0 1px
          color-mix(in srgb, var(--text) 4%, transparent);

        .toc-progress-bar {
          position: absolute;
          inset: 0 0 auto 0;
          width: 100%;
          height: 0%;
          background: color-mix(in srgb, var(--accent) 100%, var(--panel));
          transition: height 0.12s ease-out;
        }
      }

      &.over-end {
        opacity: 0;
        filter: blur(0.6px);
      }

      .toc-title {
        margin: 0 0 8px;
        font-weight: 700;
        font-size: 0.95rem;
        color: var(--muted);
        letter-spacing: 0.02em;
      }

      .toc-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        grid-template-columns: 1fr;

        .toc-item {
          line-height: 1.2;
          min-width: 0;
        }
      }

      .toc-link {
        display: block;
        padding: 3px;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        border-radius: 10px;
        color: var(--muted);
        text-decoration: none;
        border: 1px solid transparent;
        transition: font-weight 0.15s ease;
        position: relative;
        font-weight: 500;

        &:hover {
          font-weight: 700;
        }

        &.active {
        }
      }
    }
  }

  @media (max-width: 1080px) {
    .post-layout {
      grid-template-columns: 1fr;

      .toc {
        position: static;
        order: -1;
        max-height: none;
        box-shadow: 0 10px 24px var(--shadow);
      }
    }
  }

  @media (max-width: 900px) {
    .post-layout {
      .post {
        padding: 22px;
      }

      .toc-link {
        padding: 8px 10px;
      }
    }
  }
</style>
